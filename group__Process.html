<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>RapidFuzz: Process</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">RapidFuzz
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Process</div>  </div>
</div><!--header-->
<div class="contents">

<p>Processors to perform string matching on iterables.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga281d23f58aafb663ccb0055ab46a1674"><td class="memTemplParams" colspan="2">template&lt;typename Sentence1 , typename CharT  = char_type&lt;Sentence1&gt;, typename Iterable , typename Sentence2  = typename Iterable::value_type, typename ProcessorFunc  = decltype(utils::default_process&lt;std::basic_string&lt;CharT&gt;&gt;), typename ScorerFunc  = decltype(fuzz::WRatio&lt;std::basic_string&lt;CharT&gt;, std::basic_string&lt;CharT&gt;&gt;)&gt; </td></tr>
<tr class="memitem:ga281d23f58aafb663ccb0055ab46a1674"><td class="memTemplItemLeft" align="right" valign="top">optional&lt; std::pair&lt; Sentence2, percent &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Process.html#ga281d23f58aafb663ccb0055ab46a1674">rapidfuzz::process::extractOne</a> (const Sentence1 &amp;query, const Iterable &amp;choices, ProcessorFunc &amp;&amp;processor=utils::default_process&lt; std::basic_string&lt; CharT &gt;&gt;, ScorerFunc &amp;&amp;scorer=fuzz::WRatio&lt; std::basic_string&lt; CharT &gt;, std::basic_string&lt; CharT &gt;&gt;, const percent score_cutoff=0)</td></tr>
<tr class="memdesc:ga281d23f58aafb663ccb0055ab46a1674"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the best match in a list of choices by comparing them using the provided scorer functions.  <a href="group__Process.html#ga281d23f58aafb663ccb0055ab46a1674">More...</a><br /></td></tr>
<tr class="separator:ga281d23f58aafb663ccb0055ab46a1674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1a93d46f53eb67e2389d8f1b3273a23"><td class="memTemplParams" colspan="2">template&lt;typename Sentence1 , typename Iterable , typename Sentence2  = typename Iterable::value_type, typename ScorerFunc  = decltype(fuzz::WRatio&lt;Sentence1, Sentence2&gt;)&gt; </td></tr>
<tr class="memitem:gaf1a93d46f53eb67e2389d8f1b3273a23"><td class="memTemplItemLeft" align="right" valign="top">optional&lt; std::pair&lt; Sentence2, percent &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Process.html#gaf1a93d46f53eb67e2389d8f1b3273a23">rapidfuzz::process::extractOne</a> (const Sentence1 &amp;query, const Iterable &amp;choices, nullopt_t processor, ScorerFunc &amp;&amp;scorer=fuzz::WRatio&lt; Sentence1, Sentence2 &gt;, const percent score_cutoff=0)</td></tr>
<tr class="memdesc:gaf1a93d46f53eb67e2389d8f1b3273a23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the best match in a list of choices by comparing them using the provided scorer functions without any string preprocessing.  <a href="group__Process.html#gaf1a93d46f53eb67e2389d8f1b3273a23">More...</a><br /></td></tr>
<tr class="separator:gaf1a93d46f53eb67e2389d8f1b3273a23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01cdf154bff895ea7337f0874d6a495a"><td class="memTemplParams" colspan="2">template&lt;typename Sentence1 , typename CharT  = char_type&lt;Sentence1&gt;, typename Iterable , typename Sentence2  = typename Iterable::value_type, typename ProcessorFunc  = decltype(utils::default_process&lt;std::basic_string&lt;CharT&gt;&gt;), typename ScorerFunc  = decltype(fuzz::WRatio&lt;std::basic_string&lt;CharT&gt;, std::basic_string&lt;CharT&gt;&gt;)&gt; </td></tr>
<tr class="memitem:ga01cdf154bff895ea7337f0874d6a495a"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; Sentence2, percent &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Process.html#ga01cdf154bff895ea7337f0874d6a495a">rapidfuzz::process::extract</a> (const Sentence1 &amp;query, const Iterable &amp;choices, ProcessorFunc &amp;&amp;processor=utils::default_process&lt; std::basic_string&lt; CharT &gt;&gt;, ScorerFunc &amp;&amp;scorer=fuzz::WRatio&lt; std::basic_string&lt; CharT &gt;, std::basic_string&lt; CharT &gt;&gt;, const std::size_t limit=5, const percent score_cutoff=0)</td></tr>
<tr class="memdesc:ga01cdf154bff895ea7337f0874d6a495a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the best matches in a list of choices.  <a href="group__Process.html#ga01cdf154bff895ea7337f0874d6a495a">More...</a><br /></td></tr>
<tr class="separator:ga01cdf154bff895ea7337f0874d6a495a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e7288679a935a52a65792ff77fbcf93"><td class="memTemplParams" colspan="2">template&lt;typename Sentence1 , typename Iterable , typename Sentence2  = typename Iterable::value_type, typename ScorerFunc  = decltype(fuzz::WRatio&lt;Sentence1, Sentence2&gt;)&gt; </td></tr>
<tr class="memitem:ga2e7288679a935a52a65792ff77fbcf93"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; Sentence2, percent &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Process.html#ga2e7288679a935a52a65792ff77fbcf93">rapidfuzz::process::extract</a> (const Sentence1 &amp;query, const Iterable &amp;choices, nullopt_t processor, ScorerFunc &amp;&amp;scorer=fuzz::WRatio&lt; Sentence1, Sentence2 &gt;, const std::size_t limit=5, const percent score_cutoff=0)</td></tr>
<tr class="memdesc:ga2e7288679a935a52a65792ff77fbcf93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the best matches in a list of choices without any string preprocessing.  <a href="group__Process.html#ga2e7288679a935a52a65792ff77fbcf93">More...</a><br /></td></tr>
<tr class="separator:ga2e7288679a935a52a65792ff77fbcf93"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Processors to perform string matching on iterables. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga2e7288679a935a52a65792ff77fbcf93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2e7288679a935a52a65792ff77fbcf93">&#9670;&nbsp;</a></span>extract() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Sentence1 , typename Iterable , typename Sentence2  = typename Iterable::value_type, typename ScorerFunc  = decltype(fuzz::WRatio&lt;Sentence1, Sentence2&gt;)&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; Sentence2, percent &gt; &gt; rapidfuzz::process::extract </td>
          <td>(</td>
          <td class="paramtype">const Sentence1 &amp;&#160;</td>
          <td class="paramname"><em>query</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Iterable &amp;&#160;</td>
          <td class="paramname"><em>choices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nullopt_t&#160;</td>
          <td class="paramname"><em>processor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScorerFunc &amp;&amp;&#160;</td>
          <td class="paramname"><em>scorer</em> = <code>fuzz::WRatio&lt;Sentence1,&#160;Sentence2&gt;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>limit</em> = <code>5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const percent&#160;</td>
          <td class="paramname"><em>score_cutoff</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;rapidfuzz/process.hpp&gt;</code></p>

<p>Find the best matches in a list of choices without any string preprocessing. </p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> matches = <a class="code" href="group__Process.html#ga01cdf154bff895ea7337f0874d6a495a">process::extract</a>(</div>
<div class="line">  L<span class="stringliteral">&quot;example&quot;</span>,</div>
<div class="line">  std::vector&lt;std::wstring&gt;{L<span class="stringliteral">&quot;example&quot;</span>, L<span class="stringliteral">&quot;another example&quot;</span>},</div>
<div class="line">  rapidfuzz::nullopt)</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Sentence1</td><td>This is a string that can be explicitly converted to basic_string_view&lt;char_type&gt;, or provides data and size methods like std::vector&lt;char_type&gt; and has the same <code>char_type</code> as Sentence2 </td></tr>
    <tr><td class="paramname">Sentence2</td><td>This is a string that can be explicitly converted to basic_string_view&lt;char_type&gt;, or provides data and size methods like std::vector&lt;char_type&gt; and has the same <code>char_type</code> as Sentence1 </td></tr>
    <tr><td class="paramname">Iterable</td><td>This can be any Iterable of Sentence2 that can be iterated with range based for loops like e.g. vector, list or set</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">query</td><td>string we want to find </td></tr>
    <tr><td class="paramname">choices</td><td>iterable of all strings the query should be compared with. The strings have to use the same char type used for the query, but do not need the same type. (e.g. string literal as query and vector of std::string for the choices) </td></tr>
    <tr><td class="paramname">processor</td><td>This overload is selected by passing rapidfuzz::nullopt for the processor. The Strings are therefore not preprocessed </td></tr>
    <tr><td class="paramname">scorer</td><td>Optional argument to provide a scorer callback, that is used to calculate the matching ratio between two strings. Defaults to fuzz::WRatio. (Requires the function signature percent(Sentence1, Sentence2, percent)) </td></tr>
    <tr><td class="paramname">limit</td><td>maximum amount of results to return </td></tr>
    <tr><td class="paramname">score_cutoff</td><td>Optional argument for a score threshold between 0% and 100%. Matches with a lower score than this number will not be returned. Defaults to 0.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>returns a list of the best matches that have a score &gt;= score_cutoff. </dd></dl>

</div>
</div>
<a id="ga01cdf154bff895ea7337f0874d6a495a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga01cdf154bff895ea7337f0874d6a495a">&#9670;&nbsp;</a></span>extract() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Sentence1 , typename CharT  = char_type&lt;Sentence1&gt;, typename Iterable , typename Sentence2  = typename Iterable::value_type, typename ProcessorFunc  = decltype(utils::default_process&lt;std::basic_string&lt;CharT&gt;&gt;), typename ScorerFunc  = decltype(fuzz::WRatio&lt;std::basic_string&lt;CharT&gt;, std::basic_string&lt;CharT&gt;&gt;)&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; Sentence2, percent &gt; &gt; rapidfuzz::process::extract </td>
          <td>(</td>
          <td class="paramtype">const Sentence1 &amp;&#160;</td>
          <td class="paramname"><em>query</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Iterable &amp;&#160;</td>
          <td class="paramname"><em>choices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ProcessorFunc &amp;&amp;&#160;</td>
          <td class="paramname"><em>processor</em> = <code>utils::default_process&lt;std::basic_string&lt;CharT&gt;&gt;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScorerFunc &amp;&amp;&#160;</td>
          <td class="paramname"><em>scorer</em> = <code>fuzz::WRatio&lt;std::basic_string&lt;CharT&gt;,&#160;std::basic_string&lt;CharT&gt;&gt;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>limit</em> = <code>5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const percent&#160;</td>
          <td class="paramname"><em>score_cutoff</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;rapidfuzz/process.hpp&gt;</code></p>

<p>Find the best matches in a list of choices. </p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> matches = <a class="code" href="group__Process.html#ga01cdf154bff895ea7337f0874d6a495a">process::extract</a>(</div>
<div class="line">  L<span class="stringliteral">&quot;example&quot;</span>,</div>
<div class="line">  std::vector&lt;std::wstring&gt;{L<span class="stringliteral">&quot;example&quot;</span>, L<span class="stringliteral">&quot;another example&quot;</span>})</div>
</div><!-- fragment --><p>A more advanced usage providing a score_cutoff, a custom scorer and a limit: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> matches = <a class="code" href="group__Process.html#ga01cdf154bff895ea7337f0874d6a495a">process::extract</a>(</div>
<div class="line">  L<span class="stringliteral">&quot;example&quot;</span>,</div>
<div class="line">  std::vector&lt;std::wstring&gt;{L<span class="stringliteral">&quot;Example&quot;</span>, L<span class="stringliteral">&quot;example&quot;</span>, L<span class="stringliteral">&quot;another example&quot;</span>},</div>
<div class="line">  utils::default_process&lt;wchar_t&gt;,</div>
<div class="line">  fuzz::ratio&lt;std::wstring, std::wstring&gt;</div>
<div class="line">  2,</div>
<div class="line">  90);</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Sentence1</td><td>This is a string that can be explicitly converted to std::basic_string&lt;char_type&gt; and has the same <code>char_type</code> as Sentence2 </td></tr>
    <tr><td class="paramname">Sentence2</td><td>This is a string that can be explicitly converted to std::basic_string&lt;char_type&gt; and has the same <code>char_type</code> as Sentence1 </td></tr>
    <tr><td class="paramname">Iterable</td><td>This can be any Iterable of Sentence2 that can be iterated with range based for loops like e.g. vector, list or set</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">query</td><td>string we want to find </td></tr>
    <tr><td class="paramname">choices</td><td>iterable of all strings the query should be compared with. The strings have to use the same char type used for the query, but do not need the same type. (e.g. string literal as query and vector of std::string for the choices) </td></tr>
    <tr><td class="paramname">processor</td><td>Optional argument to provide a processor callback, that is used to preprocess all strings before comparing them. Defaults to utils::default_process. (Has to accept one argument both the query and each choice can be implicitly converted to and return a std::basic_string of the same <code>char_type</code> as query and choices) </td></tr>
    <tr><td class="paramname">scorer</td><td>Optional argument to provide a scorer callback, that is used to calculate the matching ratio between two strings. Defaults to fuzz::WRatio. (Requires the function signature percent(std::basic_string&lt;CharT&gt;, std::basic_string&lt;CharT&gt;, percent)) </td></tr>
    <tr><td class="paramname">limit</td><td>maximum amount of results to return </td></tr>
    <tr><td class="paramname">score_cutoff</td><td>Optional argument for a score threshold between 0% and 100%. Matches with a lower score than this number will not be returned. Defaults to 0.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>returns a list of the best matches that have a score &gt;= score_cutoff. </dd></dl>

</div>
</div>
<a id="gaf1a93d46f53eb67e2389d8f1b3273a23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf1a93d46f53eb67e2389d8f1b3273a23">&#9670;&nbsp;</a></span>extractOne() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Sentence1 , typename Iterable , typename Sentence2  = typename Iterable::value_type, typename ScorerFunc  = decltype(fuzz::WRatio&lt;Sentence1, Sentence2&gt;)&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">optional&lt; std::pair&lt; Sentence2, percent &gt; &gt; rapidfuzz::process::extractOne </td>
          <td>(</td>
          <td class="paramtype">const Sentence1 &amp;&#160;</td>
          <td class="paramname"><em>query</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Iterable &amp;&#160;</td>
          <td class="paramname"><em>choices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nullopt_t&#160;</td>
          <td class="paramname"><em>processor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScorerFunc &amp;&amp;&#160;</td>
          <td class="paramname"><em>scorer</em> = <code>fuzz::WRatio&lt;Sentence1,&#160;Sentence2&gt;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const percent&#160;</td>
          <td class="paramname"><em>score_cutoff</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;rapidfuzz/process.hpp&gt;</code></p>

<p>Finds the best match in a list of choices by comparing them using the provided scorer functions without any string preprocessing. </p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> match = <a class="code" href="group__Process.html#ga281d23f58aafb663ccb0055ab46a1674">process::extractOne</a>(</div>
<div class="line">  L<span class="stringliteral">&quot;example&quot;</span>,</div>
<div class="line">  std::vector&lt;std::wstring&gt;{L<span class="stringliteral">&quot;example&quot;</span>, L<span class="stringliteral">&quot;another example&quot;</span>},</div>
<div class="line">  rapidfuzz::nullopt)</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Sentence1</td><td>This is a string that can be explicitly converted to basic_string_view&lt;char_type&gt;, or provides data and size methods like std::vector&lt;char_type&gt; and has the same <code>char_type</code> as Sentence2 </td></tr>
    <tr><td class="paramname">Sentence2</td><td>This is a string that can be explicitly converted to basic_string_view&lt;char_type&gt;, or provides data and size methods like std::vector&lt;char_type&gt; and has the same <code>char_type</code> as Sentence1 </td></tr>
    <tr><td class="paramname">Iterable</td><td>This can be any Iterable of Sentence2 that can be iterated with range based for loops like e.g. vector, list or set</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">query</td><td>string we want to find </td></tr>
    <tr><td class="paramname">choices</td><td>iterable of all strings the query should be compared with. The strings have to use the same char type used for the query, but do not need the same type. (e.g. string literal as query and vector of std::string for the choices) </td></tr>
    <tr><td class="paramname">processor</td><td>This overload is selected by passing rapidfuzz::nullopt for the processor. The Strings are therefore not preprocessed </td></tr>
    <tr><td class="paramname">scorer</td><td>Optional argument to provide a scorer callback, that is used to calculate the matching ratio between two strings. Defaults to fuzz::WRatio. (Requires the function signature percent(Sentence1, Sentence2, percent)) </td></tr>
    <tr><td class="paramname">score_cutoff</td><td>Optional argument for a score threshold between 0% and 100%. Matches with a lower score than this number will not be returned. Defaults to 0.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Optional pair of the best match. When there is no match with a score &gt;= score_cutoff rapidfuzz::nullopt is returned (using rapidfuzz::optional to keep supporting C++11 which behavse similar to std::optional in C++17) </dd></dl>

</div>
</div>
<a id="ga281d23f58aafb663ccb0055ab46a1674"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga281d23f58aafb663ccb0055ab46a1674">&#9670;&nbsp;</a></span>extractOne() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Sentence1 , typename CharT  = char_type&lt;Sentence1&gt;, typename Iterable , typename Sentence2  = typename Iterable::value_type, typename ProcessorFunc  = decltype(utils::default_process&lt;std::basic_string&lt;CharT&gt;&gt;), typename ScorerFunc  = decltype(fuzz::WRatio&lt;std::basic_string&lt;CharT&gt;, std::basic_string&lt;CharT&gt;&gt;)&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">optional&lt; std::pair&lt; Sentence2, percent &gt; &gt; rapidfuzz::process::extractOne </td>
          <td>(</td>
          <td class="paramtype">const Sentence1 &amp;&#160;</td>
          <td class="paramname"><em>query</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Iterable &amp;&#160;</td>
          <td class="paramname"><em>choices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ProcessorFunc &amp;&amp;&#160;</td>
          <td class="paramname"><em>processor</em> = <code>utils::default_process&lt;std::basic_string&lt;CharT&gt;&gt;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScorerFunc &amp;&amp;&#160;</td>
          <td class="paramname"><em>scorer</em> = <code>fuzz::WRatio&lt;std::basic_string&lt;CharT&gt;,&#160;std::basic_string&lt;CharT&gt;&gt;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const percent&#160;</td>
          <td class="paramname"><em>score_cutoff</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;rapidfuzz/process.hpp&gt;</code></p>

<p>Finds the best match in a list of choices by comparing them using the provided scorer functions. </p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> match = <a class="code" href="group__Process.html#ga281d23f58aafb663ccb0055ab46a1674">process::extractOne</a>(</div>
<div class="line">  L<span class="stringliteral">&quot;example&quot;</span>,</div>
<div class="line">  std::vector&lt;std::wstring&gt;{L<span class="stringliteral">&quot;example&quot;</span>, L<span class="stringliteral">&quot;another example&quot;</span>})</div>
</div><!-- fragment --><p>A more advanced usage providing a score_cutoff and a custom scorer: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> match = <a class="code" href="group__Process.html#ga281d23f58aafb663ccb0055ab46a1674">process::extractOne</a>(</div>
<div class="line">  L<span class="stringliteral">&quot;example&quot;</span>,</div>
<div class="line">  std::vector&lt;std::wstring&gt;{L<span class="stringliteral">&quot;example&quot;</span>, L<span class="stringliteral">&quot;another example&quot;</span>},</div>
<div class="line">  utils::default_process&lt;std::wstring&gt;,</div>
<div class="line">  fuzz::ratio&lt;std::wstring, std::wstring&gt;</div>
<div class="line">  90);</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Sentence1</td><td>This is a string that can be explicitly converted to std::basic_string&lt;char_type&gt; and has the same <code>char_type</code> as Sentence2 </td></tr>
    <tr><td class="paramname">Sentence2</td><td>This is a string that can be explicitly converted to std::basic_string&lt;char_type&gt; and has the same <code>char_type</code> as Sentence1 </td></tr>
    <tr><td class="paramname">Iterable</td><td>This can be any Iterable of Sentence2 that can be iterated with range based for loops like e.g. vector, list or set</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">query</td><td>string we want to find </td></tr>
    <tr><td class="paramname">choices</td><td>iterable of all strings the query should be compared with. The strings have to use the same char type used for the query, but do not need the same type. (e.g. string literal as query and vector of std::string for the choices) </td></tr>
    <tr><td class="paramname">processor</td><td>Optional argument to provide a processor callback, that is used to preprocess all strings before comparing them. Defaults to utils::default_process. (Has to accept one argument both the query and each choice can be implicitly converted to and return a std::basic_string of the same <code>char_type</code> as query and choices) </td></tr>
    <tr><td class="paramname">scorer</td><td>Optional argument to provide a scorer callback, that is used to calculate the matching ratio between two strings. Defaults to fuzz::WRatio. (Requires the function signature percent(std::basic_string&lt;CharT&gt;, std::basic_string&lt;CharT&gt;, percent)) </td></tr>
    <tr><td class="paramname">score_cutoff</td><td>Optional argument for a score threshold between 0% and 100%. Matches with a lower score than this number will not be returned. Defaults to 0.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Optional pair of the best match. When there is no match with a score &gt;= score_cutoff rapidfuzz::nullopt is returned (using rapidfuzz::optional to keep supporting C++11 which behavse similar to std::optional in C++17) </dd></dl>

</div>
</div>
</div><!-- contents -->
<div class="ttc" id="agroup__Process_html_ga281d23f58aafb663ccb0055ab46a1674"><div class="ttname"><a href="group__Process.html#ga281d23f58aafb663ccb0055ab46a1674">rapidfuzz::process::extractOne</a></div><div class="ttdeci">optional&lt; std::pair&lt; Sentence2, percent &gt; &gt; extractOne(const Sentence1 &amp;query, const Iterable &amp;choices, ProcessorFunc &amp;&amp;processor=utils::default_process&lt; std::basic_string&lt; CharT &gt;&gt;, ScorerFunc &amp;&amp;scorer=fuzz::WRatio&lt; std::basic_string&lt; CharT &gt;, std::basic_string&lt; CharT &gt;&gt;, const percent score_cutoff=0)</div><div class="ttdoc">Finds the best match in a list of choices by comparing them using the provided scorer functions.</div><div class="ttdef"><b>Definition:</b> process_impl.hpp:10</div></div>
<div class="ttc" id="agroup__Process_html_ga01cdf154bff895ea7337f0874d6a495a"><div class="ttname"><a href="group__Process.html#ga01cdf154bff895ea7337f0874d6a495a">rapidfuzz::process::extract</a></div><div class="ttdeci">std::vector&lt; std::pair&lt; Sentence2, percent &gt; &gt; extract(const Sentence1 &amp;query, const Iterable &amp;choices, ProcessorFunc &amp;&amp;processor=utils::default_process&lt; std::basic_string&lt; CharT &gt;&gt;, ScorerFunc &amp;&amp;scorer=fuzz::WRatio&lt; std::basic_string&lt; CharT &gt;, std::basic_string&lt; CharT &gt;&gt;, const std::size_t limit=5, const percent score_cutoff=0)</div><div class="ttdoc">Find the best matches in a list of choices.</div><div class="ttdef"><b>Definition:</b> process_impl.hpp:67</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
